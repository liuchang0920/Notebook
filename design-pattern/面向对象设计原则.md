
| 设计原则的名称 | 定义 | 频率|
| -----| -----| ----:|
| 单一职责原则 | 一个类只负责一个功能领域中相应的职责|4|
| 开闭原则| 软件实体应对扩展开放，对修改关闭|5|
|李氏代换原则|所有引用基类对象的地方，能够透明的使用其子类的对象|5|
|依赖倒转原则|抽象不应该依赖于细节， 细节应该依赖于抽象|5|
|接口隔离原则|使用多个专门的接口，而不使用大一的总接口|2|
|合成复用原则| 尽量使用对象组合， 而不是继承来达到复用的目的|4|
|第一特法则|一个软件实体应当尽可能的少地与其他实体发生相互作用|3|


## 单一职责原则
**一个类只负责一个功能领域中的相应职责，或者可以定义为：就一个类而言，应该只有一个引起它变化的原因**

它是实现高内聚， 低耦合的知道方针，是最简单又最难运用的原则。

举例：

![](single-response.jpg)


这个类承担了太多的职责，包含了数据库的相关方法，又包含了生成表，显示表的功能，拆分:

1. DBUtil
2. CustomerDAO
3. CustomerDataChart

![](single-response-modify.jpg)


## 开闭原则
**一个软件实体，应该对扩展开放，对修改关闭。软件实体应该在不修改原有代码的情况下，进行扩展**

随着软件的规模越来越大，软件寿命越来越长，软件维护的成本越来越高，设计满足开闭原则的软件系统也变得越来越重要。

**抽象化是开闭原则的关键**


![](open-close.jpg)

``` java
if (type.equals("pie")) {
    PieChart chart = new PieChart();
    chart.display();
}
else if (type.equals("bar")) {
    BarChart chart = new BarChart();
    chart.display();
}
```

如果添加折线图，那么需要修改display()代码，违反了开闭原则

修改：

1. 增加一个抽象类AbstractChart
2. chartDisplay针对抽象的类进行编程

![](open-close-modify.jpg)

在 charDisplay的display()方法中，调用chart对象的display()方法，显示图表。
如果需要增加新的图表，只需要集成abstractchart类


注意：
xml, properties等格式的配置文件是纯文本的文件，可以直接通过VI编辑器编辑，无需变异，因此对配置文件的修改不当做对源码的修改，即可以认为是符合开闭原则的系统

## 李氏代换原则
**所有引用父类的地方必须能够透明的使用其子类的对象**

。。是实现开闭原则的重要方式之一，由于使用基类对象的放都可以使用子类对象，因此在**程序中尽量使用基类类型来对对象进行定义，而在运行时再确定其子类类型，用子类对象来替换父类对象**

1. 子类的所有方法必须在父类中生命，或者子类必须实现父类声明的所有方法
2. 尽量把父类设计为抽象类或者接口，让子类集成父类或者实现父类声明的方法。

举例：

![](Liskov.jpg)

应该使用抽象的客户类

![](Liskov-modify.jpg)


## 依赖倒转
**抽象不应该依赖于细节，细节应当依赖于抽象。换而言之，应该针对接口编程，而不应该针对实现编程**

依赖反转原则要求我们在程序代码中传递参数时或在关联关系中，尽量引用层次高的抽象类型，即使用接口和抽象类进行变量类型的声明、参数类型声明、方法返回类型声明，以及数据类型的转换等，而不要用具体类型来做这些事情。

在引入抽象层以后，系统将具有很好的灵活性，程序中尽量使用抽象层进行编程，而将具体类写在配置文件中，这样一来，系统如果发生变化，只需要针对抽象层进行扩展，并且修改配置文件，而无须修改原有系统的源代码。在不修改的情况下来扩展系统的功能，满足开闭原则的要求。

我们针对抽象层编程是，将具体类，通过依赖注入， DI的方式注入到其他对象当中。


todo..