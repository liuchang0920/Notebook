

# 第二章 批处理系统


## 特权级机制
... 
为了保证操作系统的安全，对于应用程序而言，需要限制的主要有两个方面

* 应用程序不能访问任意的地址空间（第四章 详解）
* 应用程序不能够执行某些可能破坏计算机系统的指令（本章的重点）

为了让应用程序获得操作系统的函数服务，采用传统的函数调用方式（即通常的 call 和 ret 指令或指令组合）将会直接绕过硬件的特权级保护检查。所以可以设计新的机器指令：执行环境调用（Execution Environment Call，简称 ecall ）和执行环境返回(Execution Environment Return，简称 eret )）：

* Ecall: 具有用户态到内核态的执行环境谢欢能力的函数调用指令
* eret: 具有内核态到用户态的执行环境切换能力的函数返回指令

硬件具有了这样的机制以后，还需要操作系统的配合才能最终完成对操作系统的自身的保护。
首先操作系统需要提供相应的功能代码，能在执行`eret`前准备和恢复用户态执行应用程序的上下文；
其次，在应用程序调用`ecall`指令之后，能够检查应用程序的系统调用参数，确保参数不会破坏操作系统

Eg: RISC-V 特权级架构

* 0
    * 00
    * 用户、应用模式(U, User/Application)
* 1 
    * 01
    * 监督模式(S, supervisor)
* 2 
    * 10
    * 虚拟监督模式(H, Hypervisor)
* 3 
    * 11
    * 机器模式(M, Machine)

级别数值越大，特权级别越高，掌控硬件的能力越强。

![](PrivilegeStack.png)



* SBI: supervisor binary interface 监督式二进制接口。
* ABI: Application binary interface 应用程序二进制接口
    * 也称作： syscall, System call 系统调用

可以看到，在这样的架构之下，每层特权级的软件都只能做高特权级软件允许它做的、且不会产生什么撼动高特权级软件的事情，一旦低特权级软件的要求超出了其能力范围， 就必须寻求高特权级软件的帮助，否则就是一种异常行为了。因此，在软件（应用、操作系统等）执行过程中我们经常能够看到特权级切换。如下图所示：

![](EnvironmentCallFlow.png)




## 实现应用程序

本节主要讲解如何实现被批处理系统逐个健在并运行的应用程序。...

保证应用程序的代码在U模式运行是接下来将直线的批处理系统的关键任务之一。设计的设计实现的要点：

* 应用程序的内存布局
* 应用程序发出的系统调用

